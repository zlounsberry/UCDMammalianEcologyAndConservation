Utahsum=summary(UtahDNA)
RockiesDNA = seppop(DNA)$Rockies
Rockiessum=summary(RockiesDNA)
dev.new(width=160, height=65) #This will make a new device
par(mfrow=c(2,2),mar=c(8,5,2,2))
barplot(Utahsum$loc.n.all,ylab="Number of alleles",main="Number of alleles per locus - Utah", las=3, col="dodgerblue1") # Shows # of alleles per locus
barplot(Utahsum$Hexp-sum$Hobs,main="Heterozygosity: expected-observed - Utah",ylab="Hexp - Hobs", las=3,col="dodgerblue1") # Shows expected - observed heterozygosity
barplot(Rockiessum$loc.n.all,ylab="Number of alleles",main="Number of alleles per locus - Rockies", las=3, col="firebrick1") # Shows # of alleles per locus
barplot(Rockiessum$Hexp-sum$Hobs,main="Heterozygosity: expected-observed - Rockies",ylab="Hexp - Hobs", las=3,col="firebrick1") # Shows expected - observed heterozygosity
#Checking to see if observed H is lower than expected
t.test(sum$Hexp,sum$Hobs,pair=T,var.equal=TRUE,alter="greater")
t.test(Utahsum$Hexp,Utahsum$Hobs,pair=T,var.equal=TRUE,alter="greater")
t.test(Rockiessum$Hexp,Rockiessum$Hobs,pair=T,var.equal=TRUE,alter="greater")
#Checking for deviations from HWE from pegas' locus-by-locus hw.test.
hw.test(DNA, B=1000) # B refers to the number of permutations to use for Monte-Carlo simulations
hw.test(UtahDNA, B=1000)
hw.test(RockiesDNA, B=1000)
############################################
##################PCAs######################
############################################
#(getting rid of fake Oregon popualtion)
DNA = popsub(DNA, blacklist="OregonCascades")
#PCA's are created from allele frequencies that are contained in the $tab portion of our object
#Let's explore it
DNA$tab[1:5,1:8]
dim(DNA$tab)
#There are a few things we need to do before we can do a PCA
#First, how much missing data do we have?  We will need to replace these.
sum(is.na(DNA$tab))
#Second, we need to normalize the data (subtract means of each allele and divide by their standard deviation)
#Conveniently, the function scaleGen does both
X <- scaleGen(DNA, NA.method="mean", center=TRUE, scale=TRUE) #replaces Nas; centers and scales the allele frequencies before PCA.
X[1:5, 1:8]
#Now we can do the PCA
pca1 <- dudi.pca(X, center=F, scale=F, scannf=F, nf=3)
pca1
summary(pca1)
#Important components of a dudi.pca object:
head(pca1$eig) #eigenvalues (indicating amount of variance)
pca1$eig[1:10]/sum(pca1$eig) #proporition variance explained for first 10 PCs
head(pca1$li) #the principle components (e.g. our synthetic variables)
head(pca1$c1) #the allele loadings--contribution to each PC
par(mfrow=c(1,1))
loadingplot(pca1$c1^2)
##Cool, can we clean it up? Sure! Use this complicated nightmare:
NewLoad = (pca1$c1^2)[order((pca1$c1^2)[,1], decreasing=T),]
loadingplot(NewLoad)
##Can we make it... I dunno, readable?
loadingplot(head(NewLoad,15), threshold=0)
##Hmm, what's up with the 176 allele in CPH3?
CP = DNA$tab
CPH3.176 = CP[, "CPH3.176"]
table(CPH3.176)
rownames(CP)[CPH3.176 == 1]
rownames(CP)[CPH3.176 == 2]
##Ah, 176 allele at CPH3 is a Lassen allele!!
#Let's see the pictures!
s.class(pca1$li, pop(DNA))
add.scatter.eig(pca1$eig[1:20], 3,1,2)
#We can make prettier
mycol <- funky(nPop(DNA))
#without inertia ellipses
s.class(pca1$li, pop(DNA),xax=1,yax=2, col=transp(mycol,.9), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, cellipse=0, lab="")
title("PCA - western fox", cex.main=3)
add.scatter.eig(pca1$eig[1:20], 3,1,2)
#with inertia ellipses
s.class(pca1$li, pop(DNA),xax=1,yax=2, col=transp(mycol,.9), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, clabel=.75)
title("PCA - western fox")
add.scatter.eig(pca1$eig[1:20], 3,1,2)
#We can also ignore group membership and use color as an additional representation of the first 3 PCs
par(mar=c(5,7,5,5))
colorplot(pca1$li, pca1$li, cex=3, xlab="PC 1", ylab="PC 2", cex.axis=2, cex.lab=4, tck=F)
abline(v=0,h=0,col="grey", lty=2)
colorplot(pca1$li, pca1$li, cex=3, xlab="PC 1", ylab="PC 2", add=T)
text(pca1$li[,1], pca1$li[,2], labels=pop(DNA), cex=.6, pos=1, new=FALSE) #labels points; don't use this for a large PCA, but you can use it for a DNA_noSN or foxesarse one
title("PCA - western fox", cex.main=4)
add.scatter.eig(pca1$eig[1:20], 3,1,2, ratio=.18)
#Sonora Pass and Lassen obviously influenced by drift.  Let's remove them.
length(popNames(DNA))
DNA_noSN = popsub(DNA, blacklist=c("Lassen","SonoraPass")) #the popsub command from the "poppr" library allows you to blacklist population names
length(popNames(DNA_noSN))
X2 <- scaleGen(DNA_noSN, NA.method="mean")
pca2 <- dudi.pca(X2, center=F, scale=F, scannf=F, nf=3)
#Back to the PCA with ellipses
s.class(pca2$li, pop(DNA_noSN),xax=1,yax=2, col=transp(mycol,.9), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, clabel=.75)
title("PCA - subset western fox", cex.main=4)
add.scatter.eig(pca1$eig[1:20], 3,1,2)
#colorplot
par(mar=c(5,7,5,5))
colorplot(pca2$li, pca2$li, cex=3, xlab="PC 1", ylab="PC 2", cex.axis=2, cex.lab=4, tck=F)
abline(v=0,h=0,col="grey", lty=2)
colorplot(pca2$li, pca2$li, cex=3, xlab="PC 1", ylab="PC 2", add=T)
text(pca2$li[,1], pca2$li[,2], labels=pop(DNA_noSN), cex=.6, pos=1, new=FALSE)
title("PCA - some western fox", cex.main=4)
add.scatter.eig(pca2$eig[1:20], 3,1,2, ratio=.18)
#Or we can look at just the Rockies complex
DNA_rockies <- popsub(DNA, sublist=c("Idaho","Nevada", "Rockies", "Utah"))
X3 <- scaleGen(DNA_rockies, NA.method="mean") #centers and scales the allele frequencies before PCA.
pca3 <- dudi.pca(X3, center=F, scale=F, scannf=F, nf=3)
#traditional
s.class(pca3$li, pop(DNA_rockies),xax=1,yax=2, col=c("dark orange"," dodgerblue1","dark green","firebrick1"), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, clabel=.75)
title("PCA - Rockies")
add.scatter.eig(pca3$eig[1:20], 3,1,1)
############################################
##################DAPC######################
############################################
dapc1 <- dapc(DNA, DNA$pop)
setwd("V:/3730Data/377STRs/Wildlife/R Scripts/R Stuff/20160419_CBQ_ZL_R_Workshop")
DNA=read.structure("MontaneFoxes_20160419.stru",n.ind=207,n.loc=33,onerowperind=T,col.lab=2,col.pop=1,row.marknames=1)
##Check out the data in messy number form
sum=summary(DNA)
##Check out the data is clean pretty graphic form
dev.new(width=160, height=65) #This will make a new device
par(mfrow=c(1,3), mar=c(8,5,2,2))
barplot(sum$loc.n.all,ylab="Number of alleles",main="Number of alleles per locus", las=3, col="darkgreen") # Shows # of alleles per locus
barplot(sum$Hexp-sum$Hobs,main="Heterozygosity: expected-observed",ylab="Hexp - Hobs", las=3, col=c("yellow","black","white", "red2")) # Shows expected - observed heterozygosity
barplot(sum$pop.eff,main="Sample sizes per population",ylab="Number of genotypes", las=3, col="gray25") # Number of samples per population
##Curious about comparing populations? Use "seppop" to check it out.
UtahDNA = seppop(DNA)$Utah
Utahsum=summary(UtahDNA)
RockiesDNA = seppop(DNA)$Rockies
Rockiessum=summary(RockiesDNA)
dev.new(width=160, height=65) #This will make a new device
par(mfrow=c(2,2),mar=c(8,5,2,2))
barplot(Utahsum$loc.n.all,ylab="Number of alleles",main="Number of alleles per locus - Utah", las=3, col="dodgerblue1") # Shows # of alleles per locus
barplot(Utahsum$Hexp-sum$Hobs,main="Heterozygosity: expected-observed - Utah",ylab="Hexp - Hobs", las=3,col="dodgerblue1") # Shows expected - observed heterozygosity
barplot(Rockiessum$loc.n.all,ylab="Number of alleles",main="Number of alleles per locus - Rockies", las=3, col="firebrick1") # Shows # of alleles per locus
barplot(Rockiessum$Hexp-sum$Hobs,main="Heterozygosity: expected-observed - Rockies",ylab="Hexp - Hobs", las=3,col="firebrick1") # Shows expected - observed heterozygosity
#Checking to see if observed H is lower than expected
t.test(sum$Hexp,sum$Hobs,pair=T,var.equal=TRUE,alter="greater")
t.test(Utahsum$Hexp,Utahsum$Hobs,pair=T,var.equal=TRUE,alter="greater")
t.test(Rockiessum$Hexp,Rockiessum$Hobs,pair=T,var.equal=TRUE,alter="greater")
#Checking for deviations from HWE from pegas' locus-by-locus hw.test.
hw.test(DNA, B=1000) # B refers to the number of permutations to use for Monte-Carlo simulations
hw.test(UtahDNA, B=1000)
hw.test(RockiesDNA, B=1000)
############################################
##################PCAs######################
############################################
#(getting rid of fake Oregon popualtion)
DNA = popsub(DNA, blacklist="OregonCascades")
#PCA's are created from allele frequencies that are contained in the $tab portion of our object
#Let's explore it
DNA$tab[1:5,1:8]
dim(DNA$tab)
#There are a few things we need to do before we can do a PCA
#First, how much missing data do we have?  We will need to replace these.
sum(is.na(DNA$tab))
#Second, we need to normalize the data (subtract means of each allele and divide by their standard deviation)
#Conveniently, the function scaleGen does both
X <- scaleGen(DNA, NA.method="mean", center=TRUE, scale=TRUE) #replaces Nas; centers and scales the allele frequencies before PCA.
X[1:5, 1:8]
#Now we can do the PCA
pca1 <- dudi.pca(X, center=F, scale=F, scannf=F, nf=3)
pca1
summary(pca1)
#Important components of a dudi.pca object:
head(pca1$eig) #eigenvalues (indicating amount of variance)
pca1$eig[1:10]/sum(pca1$eig) #proporition variance explained for first 10 PCs
head(pca1$li) #the principle components (e.g. our synthetic variables)
head(pca1$c1) #the allele loadings--contribution to each PC
par(mfrow=c(1,1))
loadingplot(pca1$c1^2)
##Cool, can we clean it up? Sure! Use this complicated nightmare:
NewLoad = (pca1$c1^2)[order((pca1$c1^2)[,1], decreasing=T),]
loadingplot(NewLoad)
##Can we make it... I dunno, readable?
loadingplot(head(NewLoad,15), threshold=0)
##Hmm, what's up with the 176 allele in CPH3?
CP = DNA$tab
CPH3.176 = CP[, "CPH3.176"]
table(CPH3.176)
rownames(CP)[CPH3.176 == 1]
rownames(CP)[CPH3.176 == 2]
##Ah, 176 allele at CPH3 is a Lassen allele!!
#Let's see the pictures!
s.class(pca1$li, pop(DNA))
add.scatter.eig(pca1$eig[1:20], 3,1,2)
#We can make prettier
mycol <- funky(nPop(DNA))
#without inertia ellipses
s.class(pca1$li, pop(DNA),xax=1,yax=2, col=transp(mycol,.9), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, cellipse=0, lab="")
title("PCA - western fox", cex.main=3)
add.scatter.eig(pca1$eig[1:20], 3,1,2)
#with inertia ellipses
s.class(pca1$li, pop(DNA),xax=1,yax=2, col=transp(mycol,.9), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, clabel=.75)
title("PCA - western fox")
add.scatter.eig(pca1$eig[1:20], 3,1,2)
#We can also ignore group membership and use color as an additional representation of the first 3 PCs
par(mar=c(5,7,5,5))
colorplot(pca1$li, pca1$li, cex=3, xlab="PC 1", ylab="PC 2", cex.axis=2, cex.lab=4, tck=F)
abline(v=0,h=0,col="grey", lty=2)
colorplot(pca1$li, pca1$li, cex=3, xlab="PC 1", ylab="PC 2", add=T)
text(pca1$li[,1], pca1$li[,2], labels=pop(DNA), cex=.6, pos=1, new=FALSE) #labels points; don't use this for a large PCA, but you can use it for a DNA_noSN or foxesarse one
title("PCA - western fox", cex.main=4)
add.scatter.eig(pca1$eig[1:20], 3,1,2, ratio=.18)
#Sonora Pass and Lassen obviously influenced by drift.  Let's remove them.
length(popNames(DNA))
DNA_noSN = popsub(DNA, blacklist=c("Lassen","SonoraPass")) #the popsub command from the "poppr" library allows you to blacklist population names
length(popNames(DNA_noSN))
X2 <- scaleGen(DNA_noSN, NA.method="mean")
pca2 <- dudi.pca(X2, center=F, scale=F, scannf=F, nf=3)
#Back to the PCA with ellipses
s.class(pca2$li, pop(DNA_noSN),xax=1,yax=2, col=transp(mycol,.9), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, clabel=.75)
title("PCA - subset western fox", cex.main=4)
add.scatter.eig(pca1$eig[1:20], 3,1,2)
#colorplot
par(mar=c(5,7,5,5))
colorplot(pca2$li, pca2$li, cex=3, xlab="PC 1", ylab="PC 2", cex.axis=2, cex.lab=4, tck=F)
abline(v=0,h=0,col="grey", lty=2)
colorplot(pca2$li, pca2$li, cex=3, xlab="PC 1", ylab="PC 2", add=T)
text(pca2$li[,1], pca2$li[,2], labels=pop(DNA_noSN), cex=.6, pos=1, new=FALSE)
title("PCA - some western fox", cex.main=4)
add.scatter.eig(pca2$eig[1:20], 3,1,2, ratio=.18)
#Or we can look at just the Rockies complex
DNA_rockies <- popsub(DNA, sublist=c("Idaho","Nevada", "Rockies", "Utah"))
X3 <- scaleGen(DNA_rockies, NA.method="mean") #centers and scales the allele frequencies before PCA.
pca3 <- dudi.pca(X3, center=F, scale=F, scannf=F, nf=3)
#traditional
s.class(pca3$li, pop(DNA_rockies),xax=1,yax=2, col=c("dark orange"," dodgerblue1","dark green","firebrick1"), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, clabel=.75)
title("PCA - Rockies")
add.scatter.eig(pca3$eig[1:20], 3,1,1)
############################################
##################DAPC######################
############################################
dapc1 <- dapc(DNA, DNA$pop)
#Plot
scatter(dapc1, cstar=0, col=transp(funky(nPop(DNA)),1), cex=3, leg=F, txt.leg=popNames(DNA), clab=.6)
#allele contributions to axis 1
loadingplot(dapc1$var.contr, axis=1,thres=.07, lab.jitter=1, threshold=.03)
#Let's look at DAPC and PCA side by side
dapc1 <- dapc(DNA, DNA$pop)
dapc1
#Plot
scatter(dapc1, cstar=0, col=transp(funky(nPop(DNA)),1), cex=3, leg=F, txt.leg=popNames(DNA), clab=.6)
#allele contributions to axis 1
loadingplot(dapc1$var.contr, axis=1,thres=.07, lab.jitter=1, threshold=.03)
par(mfrow=c(2,1)) #sets graphic parameters to plot 2 rows of 1
#Let's look at DAPC and PCA side by side
#PCA
s.class(pca1$li, pop(DNA),xax=1,yax=2, col=transp(funky(nPop(DNA)),.9), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, clabel=.75)
title("PCA")
#DAPC
scatter(dapc1, cstar=0, col=transp(funky(nPop(DNA)),.9), cex=3, leg=F, clab=.75)
title("DAPC")
#How about the other subsets we looked at?
dapc2 <- dapc(DNA_noSN, DNA_noSN$pop, n.pca = 40, n.da = 8)
#Look at DAPC and PCA side by side
#PCA
cstar=0, cpoint=3, grid=FALSE, clabel=.75)
title("PCA")
s.class(pca2$li, pop(DNA_noSN),xax=1,yax=2, col=transp(funky(nPop(DNA_noSN)),.9), axesell=FALSE,
scatter(dapc2, cstar=0, col=transp(funky(nPop(DNA_noSN)),.9), cex=3, leg=F, clab=.75)
#DAPC
title("DAPC")
dapc3 <- dapc(DNA_rockies, DNA_rockies$pop, n.pca=40, n.da=3)
#Look at DAPC and PCA side by side
s.class(pca3$li, pop(DNA_rockies),xax=1,yax=2, col=c("dark orange"," dark blue","dark green","dark red"), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, clabel=.75)
#PCA
title("DAPC")
title("PCA")
##So, because DAPC is maximizing among group variation and minimizing within group variation,
#it acts to "pulls apart" the centers of our pre-defined groups.
#DAPC
scatter(dapc3, cstar=0, col=c("dark orange"," dark blue","dark green","dark red"), cex=3, leg=F, clab=.75)
##But... there are two major hurdles:
scatter(dapc2, cstar=0, col=transp(funky(nPop(DNA_noSN)),.9), cex=3, leg=F, clab=.75)
title("DAPC")
dapc3 <- dapc(DNA_rockies, DNA_rockies$pop, n.pca=40, n.da=3)
#Look at DAPC and PCA side by side
#PCA
s.class(pca3$li, pop(DNA_rockies),xax=1,yax=2, col=c("dark orange"," dark blue","dark green","dark red"), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, clabel=.75)
title("PCA")
#DAPC
scatter(dapc3, cstar=0, col=c("dark orange"," dark blue","dark green","dark red"), cex=3, leg=F, clab=.75)
title("DAPC")
scatter(dapc3, cstar=0, col=c("dark orange"," dark blue","dark green","dark red"), cex=3, leg=F, clab=.75)
#PCA
s.class(pca3$li, pop(DNA_rockies),xax=1,yax=2, col=c("dark orange"," dark blue","dark green","dark red"), axesell=FALSE,
cstar=0, cpoint=3, grid=FALSE, clabel=.75)
title("PCA")
#DAPC
scatter(dapc3, cstar=0, col=c("dark orange"," dark blue","dark green","dark red"), cex=3, leg=F, clab=.75)
title("DAPC")
dapc2a <- dapc(DNA_noSN, DNA_noSN$pop, n.pca = 60, n.da = 8) #lots of PCs
dapc2b <- dapc(DNA_noSN, DNA_noSN$pop, n.pca = 5, n.da = 10) #few PCs
#plot
scatter(dapc2a, cstar=0, col=transp(mycol, .9), cex=3, leg=F, clab=.75)
scatter(dapc2b, cstar=0, col=transp(mycol, .9), cex=3, leg=F, clab=.75)
title("10 PCs analyzed")
title("50 PCs analyzed")
#structure-like plot
par(mar=c(5.1, 4.1, 1.1, 1.1), xpd=T)
compoplot(dapc2a, posi=list(x=11,y=-.01), main="50 PCs",
txt.leg=popNames(DNA_noSN), lab="", leg=F,
ncol=1, xlab="", col=mycol)
compoplot(dapc2b, posi=list(x=11,y=-.01), main="10 PCs",
txt.leg=popNames(DNA_noSN), lab="", leg=F,
ncol=1, xlab="", col=mycol)
#Clearly there are trade-offs between discriminant power and overfitting the data
#So how do we choose?
#One way is to use the a-score to optimize
#What is the a-score?
# a-score = observed discrimination - random discrimination
# essentially we repeat DAPC using random groups
# and calculate the proportion of successful reassignment
#a-score for many PCs
temp.a <- a.score(dapc2a)
temp.a
temp.b
#a score for few PCs
temp.b <- a.score(dapc2b)
#There's a function in adegenet that will optimize the numbers of PC by this a-score
oa <- optim.a.score(dapc1)
dev.off() #clear graphical parameters
#Another option is to use cross-validation to test
#(or, alternatively, we could actually withhold samples)
mat <- as.matrix(X)
grp <- pop(DNA)
n.pca = NULL, n.rep = 30, xval.plot = TRUE)
xval <- xvalDapc(mat, grp, n.pca.max = 20, training.set = 0.9,
result = "groupMean", center = TRUE, scale = FALSE,
xval[2:6]
xval <- xvalDapc(mat, grp, n.pca.max = 20, training.set = 0.9,
result = "groupMean", center = TRUE, scale = FALSE,
n.pca = NULL, n.rep = 30, xval.plot = TRUE)
xval[2:6]
#####ISSUE 2: IDENTIFYING CLUSTERS#####
#In the adegent package there is an option to identify the number of clusters and
#membership of individuals, using a K-means clustering algorithm
#K-means partitions data by minimizing the sum of squares from each point to its assigned center
#The function find.clusters goes through data iteratively, and reports the summary BIC value
#for each increasing value of K
#we transform to PCs first to make algorithm more efficient, but here we want to retain all the PCs
grp <- find.clusters(DNA, max.n.clus=15, n.pca=300)
grp <- find.clusters(DNA, max.n.clus=15, n.pca=300)
#How do inferred clusters correspond to our geographic designations?
table(pop(DNA), grp$grp)
table.value(table(pop(DNA), grp$grp), col.lab=paste("inf", 1:k), row.lab=popNames(DNA))
#determine optimal number of PCs for DAPC
table(pop(DNA), grp$grp)
table.value(table(pop(DNA), grp$grp), col.lab=paste("inf", 1:k), row.lab=popNames(DNA))
k <- 6
#How do inferred clusters correspond to our geographic designations?
table(pop(DNA), grp$grp)
table.value(table(pop(DNA), grp$grp), col.lab=paste("inf", 1:k), row.lab=popNames(DNA))
#determine optimal number of PCs for DAPC
dapc_final <- dapc(DNA, grp$grp, n.pca = optim.a.score(dapc1)$best, n.da = k-1)
#plot
par(mfrow=c(2,1))
scatter(dapc_final, cstar=0, col=transp(funky(k),.9), cex=3, leg=F, clab=.75)
title("K-means cluster")
dapc1b <- dapc(DNA, DNA$pop, n.pca = 7, n.da = 10)
scatter(dapc1b, cstar=0, col=transp(funky(nPop(DNA_noSN)),.9), cex=3, leg=F, clab=.6)
title("Pre-assigned groups")
#We can also plot posterior probabilities in a structure-like barplot
dev.off()
par(mar=c(5.1, 4.1, 1.1, 1.1), xpd=T)
compoplot(dapc_final, leg=F, lab=DNA$pop, cex.lab=.3,
ncol=1, col=funky(k))
#could customize and make prettier in ggplot2
#see ZL's stacked barplot chart
#posterior probabilities can be accessed using:
round((dapc_final$posterior),3)
compoplot(dapc_final, leg=F, lab=DNA$pop, cex=.3,
ncol=1, col=funky(k))
compoplot(dapc_final, leg=F, lab=DNA$pop, ncol=1, col=funky(k))
dev.off()
compoplot(dapc_final, leg=F, lab=DNA$pop, ncol=1, col=funky(k))
library(reshape)
posts <- melt((dapc_final$posterior), id.var=row.names())
colnames(posts) <- c("indiv", "grp", "prob")
p = ggplot(posts, aes(x = indiv, y = prob, fill = grp, width = .98)) +   #Just sets your x and y values and the fill determines groups. width = # is the width of the bar (from 0 to 1, the latter has no spacing)
geom_bar(stat = "identity") + # uses the melted data to build the bar chart and colour = "color" refers to the border color of the bar charts. Can change colour = "black" to colour = NA to get rid of borders altogether. Could be good for structure plots
scale_fill_manual(values=c("#A6CEE3", "#99CD91", "#B89B74", "#F06C45", "#ED8F47", "#825D99", "#B15928")) #This determines your color scheme manually (here just the different reds) I like this option
#scale_fill_brewer(palette = "Pastel2") #This uses RColorBrewer to set a color scheme based on their available schemes
p
p = p + scale_x_discrete(name="Individuals") +
p = p + scale_x_discrete(name="Individuals") +
scale_y_continuous(name="Posterior Probability") + #Label your axes
theme(axis.title.x = element_text(family = "sans", face="italic", colour="#990000", size=20, vjust = .5),
axis.text.x  = element_text(angle = 45, vjust=0, size=16)) + # Use angle = (some value from 0-180) to rotate x axis text
theme(axis.title.y = element_text(family = "sans", face="italic", colour="#990000", size=20, vjust = .5),
axis.text.y  = element_text(angle = 45, vjust=0, size=16)) # Use angle = (some value from 0-180) to rotate y axis text
p
round((dapc_final$posterior),3)
posts <- melt((dapc_final$posterior), id.var=row.names())
head(posts)
colnames(posts) <- c("indiv", "grp", "prob")
head(posts)
p = ggplot(posts, aes(x = indiv, y = prob, fill = grp, width = .98)) +   #Just sets your x and y values and the fill determines groups. width = # is the width of the bar (from 0 to 1, the latter has no spacing)
geom_bar(stat = "identity")
p
p = ggplot(posts, aes(x = indiv, y = prob, fill = grp, width = .98)) +   #Just sets your x and y values and the fill determines groups. width = # is the width of the bar (from 0 to 1, the latter has no spacing)
geom_bar(stat = "identity") + # uses the melted data to build the bar chart and colour = "color" refers to the border color of the bar charts. Can change colour = "black" to colour = NA to get rid of borders altogether. Could be good for structure plots
scale_fill_manual(values=c("#A6CEE3", "#99CD91", "#B89B74", "#F06C45", "#ED8F47", "#825D99", "#B15928")) #
p
setwd("V:/3730Data/377STRs/Wildlife/R Scripts/R Stuff/stackedbarggplot2")
library(grid)
library(gridExtra)
NF <- read.table("Newfoundland_Q.txt", header=TRUE)
NF.m <- melt(NF, id.var="ID")
#NF.m
ggplot(NF.m, aes(x = ID, y = value, fill = variable, width = 1, ymax=1.0, ymin=0.0)) + 	#Just sets your x and y values and the fill determines groups. width = # is the width of the bar (from 0 to 1, the latter has no spacing)
geom_bar(stat = "identity", colour = "white") + #colour="white" makes the sep. lines between bars white
coord_cartesian(ylim = c(-0.1,1)) + #Set your Y limit to be bound 0-1
scale_fill_manual(values=c("gray50", "black")) +  #Sets the colours (assigned by fill = variable above)
ylab("Probability of assignment\n") + #added newline char to increase space between label
theme(axis.title.y = element_text(color="black", size=35, face="bold", vjust=0)) +
theme(axis.text.y = element_text(color="black", size=20)) +
theme(axis.title.x = element_text(color="black", size=35, face="bold")) +
xlab("Individuals") +
annotation_custom(grob=textGrob("wild",gp=gpar(fontsize=30, col="black")), xmin=20,xmax=20,ymin=-0.05,ymax=-0.05) +
theme(axis.text.x = element_blank()) +
theme(axis.ticks.x = element_blank()) +
annotation_custom(grob=textGrob("fur farm",gp=gpar(fontsize=30, col="black")), xmin=80,xmax=80,ymin=-0.05,ymax=-0.05) +
geom_vline(xintercept = 43.5, lwd=1, colour="black", lty="longdash") +
theme(panel.background = element_blank()) +
guides(fill=FALSE)
head(NF.m)
class(posts$grp)
posts$grp <- as.factor(posts$grp)
class(posts$grp)
p = ggplot(posts, aes(x = indiv, y = prob, fill = grp, width = .98)) +   #Just sets your x and y values and the fill determines groups. width = # is the width of the bar (from 0 to 1, the latter has no spacing)
geom_bar(stat = "identity") + # uses the melted data to build the bar chart and colour = "color" refers to the border color of the bar charts. Can change colour = "black" to colour = NA to get rid of borders altogether. Could be good for structure plots
scale_fill_manual(values=c("#A6CEE3", "#99CD91", "#B89B74", "#F06C45", "#ED8F47", "#825D99", "#B15928")) #This determines your color scheme manually (here just the different reds) I like this option
#scale_fill_brewer(palette = "Pastel2") #This uses RColorBrewer to set a color scheme based on their available schemes
p
ggplot(posts, aes(x = indiv, y = prob, fill = grp, width = 1, ymax=1.0, ymin=0.0)) + 	#Just sets your x and y values and the fill determines groups. width = # is the width of the bar (from 0 to 1, the latter has no spacing)
geom_bar(stat = "identity", colour = "white") + #colour="white" makes the sep. lines between bars white
scale_fill_manual(values=c("gray50", "black")) +  #Sets the colours (assigned by fill = variable above)
coord_cartesian(ylim = c(-0.1,1)) + #Set your Y limit to be bound 0-1
ylab("Probability of assignment\n") + #added newline char to increase space between label
theme(axis.title.y = element_text(color="black", size=35, face="bold", vjust=0)) +
theme(axis.title.x = element_text(color="black", size=35, face="bold")) +
theme(axis.text.y = element_text(color="black", size=20)) +
xlab("Individuals") +
theme(axis.text.x = element_blank()) +
annotation_custom(grob=textGrob("wild",gp=gpar(fontsize=30, col="black")), xmin=20,xmax=20,ymin=-0.05,ymax=-0.05) +
annotation_custom(grob=textGrob("fur farm",gp=gpar(fontsize=30, col="black")), xmin=80,xmax=80,ymin=-0.05,ymax=-0.05) +
theme(axis.ticks.x = element_blank()) +
theme(panel.background = element_blank()) +
geom_vline(xintercept = 43.5, lwd=1, colour="black", lty="longdash") +
guides(fill=FALSE)
ggplot(posts, aes(x = indiv, y = prob, fill = grp, width = 1, ymax=1.0, ymin=0.0)) + 	#Just sets your x and y values and the fill determines groups. width = # is the width of the bar (from 0 to 1, the latter has no spacing)
geom_bar(stat = "identity", colour = "white") + #colour="white" makes the sep. lines between bars white
scale_fill_manual(values=c("#A6CEE3", "#99CD91", "#B89B74", "#F06C45", "#ED8F47", "#825D99", "#B15928")) +  #Sets the colours (assigned by fill = variable above)
coord_cartesian(ylim = c(-0.1,1)) + #Set your Y limit to be bound 0-1
ylab("Probability of assignment\n") + #added newline char to increase space between label
theme(axis.title.y = element_text(color="black", size=35, face="bold", vjust=0)) +
theme(axis.title.x = element_text(color="black", size=35, face="bold")) +
theme(axis.text.y = element_text(color="black", size=20)) +
xlab("Individuals") +
theme(axis.text.x = element_blank()) +
annotation_custom(grob=textGrob("wild",gp=gpar(fontsize=30, col="black")), xmin=20,xmax=20,ymin=-0.05,ymax=-0.05) +
annotation_custom(grob=textGrob("fur farm",gp=gpar(fontsize=30, col="black")), xmin=80,xmax=80,ymin=-0.05,ymax=-0.05) +
theme(axis.ticks.x = element_blank()) +
theme(panel.background = element_blank()) +
geom_vline(xintercept = 43.5, lwd=1, colour="black", lty="longdash") +
guides(fill=FALSE)
p = p + scale_x_discrete(name="Individuals") +
ggplot(posts, aes(x = indiv, y = prob, fill = grp, width = 1, ymax=1.0, ymin=0.0)) + 	#Just sets your x and y values and the fill determines groups. width = # is the width of the bar (from 0 to 1, the latter has no spacing)
geom_bar(stat = "identity", colour = "white") + #colour="white" makes the sep. lines between bars white
scale_fill_manual(values=c("#A6CEE3", "#99CD91", "#B89B74", "#F06C45", "#ED8F47", "#825D99", "#B15928")) +  #Sets the colours (assigned by fill = variable above)
coord_cartesian(ylim = c(-0.1,1)) + #Set your Y limit to be bound 0-1
ylab("Probability of assignment\n") + #added newline char to increase space between label
theme(axis.title.y = element_text(color="black", size=35, face="bold", vjust=0)) +
theme(axis.title.x = element_text(color="black", size=35, face="bold")) +
theme(axis.text.y = element_text(color="black", size=20)) +
xlab("Individuals") +
theme(axis.text.x = element_blank()) +
theme(axis.ticks.x = element_blank()) +
theme(panel.background = element_blank()) +
guides(fill=FALSE)
ggplot(posts, aes(x = indiv, y = prob, fill = grp, width = 1, ymax=1.0, ymin=0.0)) + 	#Just sets your x and y values and the fill determines groups. width = # is the width of the bar (from 0 to 1, the latter has no spacing)
geom_bar(stat = "identity", colour = "white") + #colour="white" makes the sep. lines between bars white
scale_fill_manual(values=c("#A6CEE3", "#99CD91", "#B89B74", "#F06C45", "#ED8F47", "#825D99", "#B15928")) +  #Sets the colours (assigned by fill = variable above)
coord_cartesian(ylim = c(-0.1,1)) + #Set your Y limit to be bound 0-1
ylab("Probability of assignment\n") + #added newline char to increase space between label
theme(axis.title.y = element_text(color="black", size=35, face="bold", vjust=0)) +
theme(axis.title.x = element_text(color="black", size=35, face="bold")) +
theme(axis.text.y = element_text(color="black", size=20)) +
theme(axis.text.x = element_blank()) +
xlab("Individuals") +
theme(axis.ticks.x = element_blank()) +
theme(panel.background = element_blank()) +
guides(fill=FALSE)
ggplot(posts, aes(x = indiv, y = prob, fill = grp, width = 1, ymax=1.0, ymin=0.0)) + 	#Just sets your x and y values and the fill determines groups. width = # is the width of the bar (from 0 to 1, the latter has no spacing)
geom_bar(stat = "identity", colour = "white") + #colour="white" makes the sep. lines between bars white
geom_text(data=DNA$pop,aes(x=x,y=0,label=lab),vjust=0)
scale_fill_manual(values=c("#A6CEE3", "#99CD91", "#B89B74", "#F06C45", "#ED8F47", "#825D99", "#B15928")) +  #Sets the colours (assigned by fill = variable above)
coord_cartesian(ylim = c(-0.1,1)) + #Set your Y limit to be bound 0-1
ylab("Probability of assignment\n") + #added newline char to increase space between label
theme(axis.title.y = element_text(color="black", size=35, face="bold", vjust=0)) +
theme(axis.title.x = element_text(color="black", size=35, face="bold")) +
theme(axis.text.y = element_text(color="black", size=20)) +
xlab("Individuals") +
theme(axis.text.x = element_blank()) +
theme(axis.ticks.x = element_blank()) +
theme(panel.background = element_blank()) +
guides(fill=FALSE)

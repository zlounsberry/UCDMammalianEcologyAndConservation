setwd("V:/3730Data/377STRs/Wildlife/R Scripts/R Stuff/adegenet")
library("adegenet")
mycol=transp(c("black","red","blue","purple","green","yellow"), 0.8)


############################################################
####   This section is for looking for populations   #######
############################################################

DNA=read.structure("4stru_deer.stru", n.ind=209,n.loc=10,onerowperind=T,col.lab=1,col.pop=2,row.marknames=1) #This is 4stru.txt with the file handle changed (structure formatted txt file)

par(mfrow=c(2,2))

DNAgrp=find.clusters(DNA, max.n.clust=40, n.pca=100) # This is your test for the number of clusters (k's). max.n.clust refers to the maximum number of putative clusters.
5
	##This will ask you to choose a number of PCs to retain. No reason not to take as many as possible (I did 100, hence 'n.pca=100')
	##It will then ask you to check out the BIC vs. cluster size. Pick the k associated with the lowest (meaningful) BIC value.
abline(v=5, lty=2)
par(xpd=T)

dapc1=dapc(DNA, DNAgrp$grp, n.pca=40, n.da=5) #calculate your dapc (it will prompt you to choose # of PC and discriminate functions to use.
opt1=optim.a.score(dapc1, plot=T)
	##This calculates the number of PCs that give you the best a value
dapc2=dapc(DNA, DNAgrp$grp, n.pca=opt1$best, n.da=5) 

scatter(dapc1, cstar=0, col=mycol, cex=4, leg=T, txt.leg=paste("Cluster",1:5), clab=0, scree.pca=F, inset.pca=c(0.15,0.05), ratio.pca=0.2)
text(-11,600,"Clusters", cex=3)
	##scatter(dapc2, cstar=0, col=mycol, cex=3, leg=T, txt.leg=c("Wild 1","Wild 2","Fur Farm"), clab=0) 
	##scatter plots your dapc1 object. 
	##scree.da=T, inset.da=c(0.75,0.05), ratio.da=0.2, scree.pca=T, inset.pca=c(0.15,0.05), ratio.pca=0.2 plots both nicely (with this graphics window, anyway).

dapc1=dapc(DNA, DNA$pop, n.pca=40, n.da=3) #calculate your dapc (it will prompt you to choose # of PC and discriminate functions to use.
opt1=optim.a.score(dapc1, plot=F)
dapc1=dapc(DNA, DNA$pop, n.pca=opt1$best, n.da=3) 
scatter(dapc1, col=mycol, cex=3, leg=T, clab=0) 
text(-7,60,"Transects",cex=3)







##PCA##

X = tab(DNA, NA.method="zero") #tab() retrieves a matrix of allele data and NA.methods="zero" sets NA's (missing) to 0.
pca1 <- dudi.pca(X,scannf=FALSE,scale=FALSE) #this makes an object "pca1" that has the results of your PCA.
temp <- as.integer(pop(DNA)) #makes a temporary object to be used for myCol and myPch (below) that convert your populations to integers
myCol <- transp(c("black","red","blue","purple","green","yellow"),.7)[temp] 
plot(pca1$li, col="black", cex=2, pch=myPch, bg=myCol,inset.pca=c(0.15,0.05), ratio.pca=0.2) # $li refers to the principal components, so that's what we're plotting here


s.class(pca1$li,pop(DNA),xax=1,yax=2,label=T,col=myCol,axesell=FALSE,cstar=1,cpoint=5,grid=FALSE)
text(-2,2,"PCA", cex=3)

contrib <- loadingplot(dapc1$var.contr, axis=1,thres=.07, lab.jitter=1) #To see which loci are contributing to each PC
	##This bit looks at

############################################################


############################################################
#Don't use this section yet, it's a work in progress... Looking at allele frequencies between the two populations at a single locus, p 22 of dapc tutorial
temp=seploc(DNA)
temp[["RF2054"]]$tab
RF2054=temp[["RF2054"]]$tab
FREQ_RF2054=apply(RF2054, 2, function(e) tapply(e, pop(DNA), mean, na.rm=TRUE))
matplot(FREQ_RF2054, pch=c("1","2","3","4","5","6","7","8"), type="b",xlab="population",ylab="allele frequency", xaxt="n",cex=1.5, main="RF2054") 
############################################################

############################################################
############Structure-like DAPC analyses####################
############################################################

##This is better with user-defined (e.g., biological) populations rather than populations defined by find.clusters
assignplot(dapc1, cex=0.4)
assignplot(dapc2, cex=0.4)

compoplot(dapc1)
compoplot(dapc2)

temp = which(apply(dapc1$posterior,1, function(e) all(e<.001)))
temp
compoplot(dapc1, subset=temp)
summary(dapc1)

############################################################
##################Using the a-score#########################
############################################################

##This section will help optimize your number of principal components to avoid overfitting or losing information
##I used the dapc from the pre-defined populations as well as the k-mean method of determining the number of populations (dapc1 and dapc2, respectively):

par(xpd=T, mfrow=c(3,2))
dapc1=dapc(DNA, DNA$pop, n.pca=50, n.da=10) 
	##This is our original dapc for the individuals of known population

scatter(dapc1, cstar=0, col=mycol, cex=3, leg=T, txt.leg=c("Fur Farm", "Wild"), clab=1) 
	##This plots your dapc using 50 PCs

compoplot(dapc1, lab="", posi=list(x=12,y=-.01), col=mycol)

temp1=a.score(dapc1, n.sim=100)
	##This calculates the a score of dapc1 using 100 simulations

opt1=optim.a.score(dapc1, plot=T)
	##This calculates the number of PCs that give you the best a value

dapc1=dapc(DNA, DNA$pop, n.pca=2, n.da=10) 
	##This re-does your dapc using the best pca value given by the previous command
	##optim.a.score says 1 pca is best. "opt1$best" is equal to 1 in this case, but I went with 2 to give more information without necessarily overfitting too much.

dapc1=dapc(DNA, DNA$pop, n.pca=3, n.da=10)
temp2=a.score(dapc1, n.sim=100)

##For a structure-like look at the hybrids:
dapc4=dapc(DNAHyb, DNAHyb$pop, n.pca=4, n.da=3) 
scatter(dapc1, cstar=0, col=mycol, cex=3, leg=T, txt.leg=c("Fur Farm", "Wild"), clab=1) 
compoplot(dapc1, lab="", posi=list(x=12,y=-.01), col=mycol)

##Or my own person version based on the

##Now doing the same thing with the same data using the k-mean approach
DNAgrp=find.clusters(DNA, max.n.clust=40, n.pca=100) # This is your test for the number of clusters (k's). max.n.clust refers to the maximum number of putative clusters.
par(xpd=T, mfrow=c(2,2))
dapc2=dapc(DNA, DNAgrp$grp, n.pca=45, n.da=10) 
scatter(dapc2, cstar=0, col=mycol, cex=3, leg=T, txt.leg=paste("Cluster",1:2), clab=0, scree.pca=F, inset.pca=c(0.15,0.05), ratio.pca=0.2)
temp2=a.score(dapc2)
opt2=optim.a.score(dapc2, plot=T)
dapc2=dapc(DNA, DNAgrp$grp, n.pca=opt1$best, n.da=10) 
scatter(dapc2, cstar=0, col=mycol, cex=3, leg=T, txt.leg=paste("Cluster",1:2), clab=0, scree.pca=F, inset.pca=c(0.15,0.05), ratio.pca=0.2)
 



##################cross validation

DNA=read.structure("4stru2.stru", n.ind=143,n.loc=21,onerowperind=T,col.lab=1,col.pop=2,row.marknames=1) #This is 4stru.txt with the file handle changed (structure formatted txt file)
X=tab(DNA, NA.method="zero")
grp=pop(DNA)
xval <- xvalDapc(X, grp, n.pca.max = 300, training.set = 0.9,result = "groupMean", center = TRUE, scale = FALSE,n.pca = NULL, n.rep = 90, xval.plot = TRUE)
xval[2:6] # The lowest MSE number is what you want.


############################################################
########Supplementary individuals (unknown origin)##########
############################################################
#First, simulate some hybrids
DNA=read.structure("4stru2.stru", n.ind=143,n.loc=21,onerowperind=T,col.lab=1,col.pop=2,row.marknames=1) 
	##Read your data in

temp=seppop(DNA) 
	##This splits up the populations

FF=temp$FurFarm[1:50] 
	##Making Fur farm group an object using the first 50 individuals in the population.

WI=temp$Wild[1:50] 
	##Making wild group an object using the first 50 individuals in the population.

Hyb=hybridize(WI, FF, n=50, pop="hybrids") 
	##Hybridize the two populations to create 50 hybrid offspring
	##The pop="hybrids" assigns them a population in the Hyb object (so using Hyb$hybrids will print your hybrid offspring)

DNAHyb=repool(c(DNA,Hyb)) 
	##repools the data to make sure they are in the correct format. This is necessary because the hybridization step will occasionally drop monomorphic loci from the dataset

temp=seppop(DNAHyb) 
	##Separate the populations so you can make the hybrids  your "unknown" data in the next steps

DNAgrp=find.clusters(DNA, max.n.clust=40, n.pca=100) #Make an object with 3 clusters here
3
	##Just like in previous sections, make your pca. I selected 3 populations for this dataset
	
dapc3=dapc(DNA, DNAgrp$grp, n.pca=3, n.da=3) 
	##Make your PCA (I arbitrarily picked 20 for my n.pca, but you can use more or less based on criteria outlines in previous sections).
	##This gets your baseline dapc that you will add your new data to

pred.sup=predict.dapc(dapc3, newdata=temp$hybrids) 
	##This incorporates temp$hybrids (once again this comes from the 'pop="hybrids"' line above.
	##This bit will predict the likelihood of assignment for the hybrid individuals

pred.sup$posterior 
	##This gives each individual's likelihood of assignment into each population!

###To plot it###
par(xpd=TRUE, mfrow=c(1,2))
mycol=transp(c("black","red","blue","purple","green","yellow"),0.9)
	##Assign colors to object mycol

#col.points = transp(mycol[as.integer(pop(DNA))],.8) #original grouping based on original file
col.points = transp(mycol[as.integer(DNAgrp$grp)],.8) #new grouping based find.clusters step above
	##Makes specific points for the populations in the DNA dataset

scatter(dapc3, col=col.points, bg="white", scree.da=0, pch="", cstar=0, clab=0, legend=F)
	##plot an empty scatterplot to add points to (including known and unknown individuals separately)
	##Note: legend turned off because it only wants to give me one population color currently...

points(dapc3$ind.coord[,1], dapc3$ind.coord[,2], pch=20,col=col.points, cex=3)
	##Add your original dapc coordinates to the plot (color coded by pop, here)

points(pred.sup$ind.scores[,1], pred.sup$ind.scores[,2], pch=20,col=transp("green", 0.8), cex=3)
	##Plot your unknowns (in green, here)

add.scatter.eig(dapc3$eig,15,1,2, posi="bottomright", inset=.02)
	##Add your eigenvalue plot


###Now add some F4 hybrids!###
F3=hybridize(WI, Hyb, n=50, pop="F3") 
F4=hybridize(WI, F3, n=50, pop="F4") 
	##Backcross the hybrid pop with wilds, and then this group to the wild group 

DNAF4=repool(c(DNA,F4)) 
	##repools the data to make sure they are in the correct format

temp1=seppop(DNAF4)

pred.sup1=predict.dapc(dapc3, newdata=temp1$F4) 

par(xpd=TRUE)
mycol=transp(c("black","red","blue","purple","green","yellow"),0.9)
	##Assign colors to object mycol

#col.points = transp(mycol[as.integer(pop(DNA))],.8) #original grouping based on original file
col.points = transp(mycol[as.integer(DNAgrp$grp)],.8) #new grouping based find.clusters step above
	##Makes specific points for the populations in the DNA dataset

scatter(dapc3, col=col.points, bg="white", scree.da=0, pch="", cstar=0, clab=0, legend=F)
	##plot an empty scatterplot to add points to (including known and unknown individuals separately)
	##Note: legend turned off because it only wants to give me one population color currently...

points(dapc3$ind.coord[,1], dapc3$ind.coord[,2], pch=20,col=col.points, cex=3)
	##Add your original dapc coordinates to the plot (color coded by pop, here)

points(pred.sup1$ind.scores[,1], pred.sup1$ind.scores[,2], pch=20,col=transp("purple", 0.8), cex=3)
	##Plot your unknowns (in green, here)

pred.sup1$posterior 

add.scatter.eig(dapc3$eig,15,1,2, posi="bottomright", inset=.02)
	##Add your eigenvalue plot

